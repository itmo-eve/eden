[!exec:bash] stop
[!exec:grep] stop
[!exec:sed] stop
[!exec:curl] stop

# This test deploys two apps into EVE and checks access between them trough network
# Inside apps there are nginx and curl services.
#     curl try to download page provided in $url variable and save it into received-data.html file.
#     Nginx serve $url variable content at /user-data.html endpoint and received-data.html at /received-data.html endpoint.
#     $url variable set from metadata information provided to EVE on application start
# For the first app we define url=TEST_SEQUENCE and we can get it from /user-data.html endpoint
# For the second app we define url=http://internalIP/user-data.html (where internalIP - is IP of first app, we obtain it from the running app)
# Curl service of second app follow $url variable, try to access first app, and save output into received-data.html
# We try to get content of received-data.html through HTTP GET to second app /received-data.html endpoint
#     and compare result with the TEST_SEQUENCE

# string to use as the testing sequence
{{$test_data := "TEST_SEQUENCE"}}

# create or get two networks for the test
eden network create 10.1.0.0/24
eden network create 10.2.0.0/24

# obtain network list
eden network ls

# copy output to the temp file
cp stdout network_ls

# parse the file in networks_process.sh
exec bash networks_process.sh

# read the result of parsing
source .env

# deploy the first application by nested escript
test eden.escript.test -test.run TestEdenScripts/deploy_app -test.v  -testdata {{EdenConfig "eden.root"}}/../tests/network/testdata/

# execute the script for waiting RUNNING state and obtain internal IP
exec -t 15m bash wait_and_get_ip.sh

# read the result of parsing
source .env

# deploy the second application by nested escript
test eden.escript.test -test.run TestEdenScripts/deploy_app -test.v  -testdata {{EdenConfig "eden.root"}}/../tests/network/testdata/

# execute the script for waiting RUNNING state and obtain the testing sequence from the second app
exec -t 15m bash wait_app2.sh

# expect the testing sequence in stdout
stdout '{{$test_data}}'

# teardown applications
eden pod delete app1
eden pod delete app2

# Test's config file
-- eden-config.yml --
test:
    controller: adam://{{EdenConfig "adam.ip"}}:{{EdenConfig "adam.port"}}
    eve:
      {{EdenConfig "eve.name"}}:
        onboard-cert: {{EdenConfigPath "eve.cert"}}
        serial: "{{EdenConfig "eve.serial"}}"
        model: {{EdenConfig "eve.devmodel"}}

-- networks_process.sh --
#!/bin/sh

echo "defining of environment variables for the first app"

echo net=$(grep '10.2.0.0/24' network_ls | sed '$s/\(^[^\t]*\).*$/\1/')>.env
echo external_port=''>>.env
echo metadata={{$test_data}}>>.env
echo name=app1>>.env
echo vnc=1>>.env

-- wait_and_get_ip.sh --
#!/bin/sh

echo "waiting for app1 running state"

EDEN={{EdenConfig "eden.root"}}/{{EdenConfig "eden.bin-dist"}}/{{EdenConfig "eden.eden-bin"}}
until $EDEN pod ps | grep app1 | grep RUNNING; do sleep 3; done
$EDEN pod ps>pod_ps

echo "defining of environment variables for the second app"

echo net=$(grep '10.1.0.0/24' network_ls | sed '$s/\(^[^\t]*\).*$/\1/'),$(grep '10.2.0.0/24' network_ls | sed '$s/\(^[^\t]*\).*$/\1/')>.env
echo external_port=-p 8027:80>>.env
echo metadata=http://$(grep '10.2.0.' pod_ps | grep -o -E '10.2.0.[0-9]{1,3}')/user-data.html>>.env
echo name=app2>>.env
echo vnc=2>>.env

-- wait_app2.sh --
#!/bin/sh

echo "waiting for app2 running state"

EDEN={{EdenConfig "eden.root"}}/{{EdenConfig "eden.bin-dist"}}/{{EdenConfig "eden.eden-bin"}}
until $EDEN pod ps | grep app2 | grep RUNNING; do sleep 3; done

echo "waiting for the second app response"

address=http://$($EDEN pod ps|grep app2|grep -o -E '([0-9]{1,3}[\.]){3}[0-9]{1,3}:8027')/received-data.html
until curl $address | grep {{$test_data}}; do sleep 3; done